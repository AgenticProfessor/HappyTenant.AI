'use client'

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

// Types
export type ChargeType =
  | 'RENT'
  | 'SECURITY_DEPOSIT'
  | 'PET_DEPOSIT'
  | 'PET_RENT'
  | 'LATE_FEE'
  | 'UTILITY'
  | 'PARKING'
  | 'STORAGE'
  | 'MAINTENANCE'
  | 'APPLICATION_FEE'
  | 'MOVE_IN_FEE'
  | 'MOVE_OUT_FEE'
  | 'CLEANING'
  | 'DAMAGES'
  | 'NSF_FEE'
  | 'LEGAL_FEE'
  | 'OTHER'

export type ChargeStatus = 'DUE' | 'PARTIAL' | 'PAID' | 'OVERDUE' | 'VOID' | 'WAIVED'

export interface PaymentAllocation {
  id: string
  amount: number
  allocatedAt: string
  payment: {
    id: string
    amount: number
    method: string
    status: string
    receivedAt: string
  }
}

export interface Charge {
  id: string
  leaseId: string
  tenantId: string
  type: ChargeType
  description: string
  amount: number
  dueDate: string
  billingPeriodStart?: string | null
  billingPeriodEnd?: string | null
  status: ChargeStatus
  isAutoGenerated: boolean
  notes?: string | null
  createdAt: string
  updatedAt: string
  lease: {
    id: string
    unit: {
      id: string
      unitNumber: string
      property: {
        id: string
        name: string
        addressLine1: string
      }
    }
  }
  tenant: {
    id: string
    firstName: string
    lastName: string
    email: string
  }
  paymentAllocations: PaymentAllocation[]
}

export interface ChargeSummary {
  totalDue: number
  totalPaid: number
  totalOverdue: number
  count: number
}

export interface CreateChargeInput {
  leaseId: string
  tenantId: string
  type: ChargeType
  description: string
  amount: number
  dueDate: string
  billingPeriodStart?: string
  billingPeriodEnd?: string
  notes?: string
}

export interface UpdateChargeInput {
  description?: string
  amount?: number
  dueDate?: string
  status?: ChargeStatus
  notes?: string
}

// API Functions
async function fetchCharges(filters?: {
  status?: string
  type?: string
  leaseId?: string
  tenantId?: string
  propertyId?: string
  startDate?: string
  endDate?: string
}): Promise<{ charges: Charge[]; summary: ChargeSummary }> {
  const params = new URLSearchParams()
  if (filters?.status) params.set('status', filters.status)
  if (filters?.type) params.set('type', filters.type)
  if (filters?.leaseId) params.set('leaseId', filters.leaseId)
  if (filters?.tenantId) params.set('tenantId', filters.tenantId)
  if (filters?.propertyId) params.set('propertyId', filters.propertyId)
  if (filters?.startDate) params.set('startDate', filters.startDate)
  if (filters?.endDate) params.set('endDate', filters.endDate)

  const response = await fetch(`/api/charges?${params.toString()}`)
  if (!response.ok) {
    throw new Error('Failed to fetch charges')
  }
  return response.json()
}

async function fetchCharge(id: string): Promise<{
  charge: Charge
  paymentSummary: {
    totalAmount: number
    totalAllocated: number
    remainingBalance: number
    isFullyPaid: boolean
    paymentCount: number
  }
}> {
  const response = await fetch(`/api/charges/${id}`)
  if (!response.ok) {
    throw new Error('Failed to fetch charge')
  }
  return response.json()
}

async function createCharge(data: CreateChargeInput): Promise<{ charge: Charge }> {
  const response = await fetch('/api/charges', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  })
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error || 'Failed to create charge')
  }
  return response.json()
}

async function updateCharge(id: string, data: UpdateChargeInput): Promise<{ charge: Charge }> {
  const response = await fetch(`/api/charges/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  })
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error || 'Failed to update charge')
  }
  return response.json()
}

async function deleteCharge(id: string): Promise<{ success: boolean }> {
  const response = await fetch(`/api/charges/${id}`, {
    method: 'DELETE',
  })
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error || 'Failed to delete charge')
  }
  return response.json()
}

// Query Keys
export const chargeKeys = {
  all: ['charges'] as const,
  lists: () => [...chargeKeys.all, 'list'] as const,
  list: (filters?: Record<string, string | undefined>) =>
    [...chargeKeys.lists(), filters] as const,
  details: () => [...chargeKeys.all, 'detail'] as const,
  detail: (id: string) => [...chargeKeys.details(), id] as const,
}

// Hooks
export function useCharges(filters?: {
  status?: string
  type?: string
  leaseId?: string
  tenantId?: string
  propertyId?: string
  startDate?: string
  endDate?: string
}) {
  return useQuery({
    queryKey: chargeKeys.list(filters),
    queryFn: () => fetchCharges(filters),
  })
}

export function useCharge(id: string) {
  return useQuery({
    queryKey: chargeKeys.detail(id),
    queryFn: () => fetchCharge(id),
    enabled: !!id,
  })
}

export function useCreateCharge() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: createCharge,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: chargeKeys.lists() })
      queryClient.invalidateQueries({ queryKey: ['leases'] })
    },
  })
}

export function useUpdateCharge() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateChargeInput }) =>
      updateCharge(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: chargeKeys.lists() })
      queryClient.invalidateQueries({ queryKey: chargeKeys.detail(id) })
      queryClient.invalidateQueries({ queryKey: ['leases'] })
    },
  })
}

export function useDeleteCharge() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: deleteCharge,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: chargeKeys.lists() })
      queryClient.invalidateQueries({ queryKey: ['leases'] })
    },
  })
}

// Utility functions
export function getChargeStatusColor(status: ChargeStatus): string {
  const colors: Record<ChargeStatus, string> = {
    DUE: 'bg-yellow-100 text-yellow-800',
    PARTIAL: 'bg-blue-100 text-blue-800',
    PAID: 'bg-green-100 text-green-800',
    OVERDUE: 'bg-red-100 text-red-800',
    VOID: 'bg-gray-100 text-gray-800',
    WAIVED: 'bg-purple-100 text-purple-800',
  }
  return colors[status] || 'bg-gray-100 text-gray-800'
}

export function getChargeTypeLabel(type: ChargeType): string {
  const labels: Record<ChargeType, string> = {
    RENT: 'Rent',
    SECURITY_DEPOSIT: 'Security Deposit',
    PET_DEPOSIT: 'Pet Deposit',
    PET_RENT: 'Pet Rent',
    LATE_FEE: 'Late Fee',
    UTILITY: 'Utility',
    PARKING: 'Parking',
    STORAGE: 'Storage',
    MAINTENANCE: 'Maintenance',
    APPLICATION_FEE: 'Application Fee',
    MOVE_IN_FEE: 'Move-in Fee',
    MOVE_OUT_FEE: 'Move-out Fee',
    CLEANING: 'Cleaning',
    DAMAGES: 'Damages',
    NSF_FEE: 'NSF Fee',
    LEGAL_FEE: 'Legal Fee',
    OTHER: 'Other',
  }
  return labels[type] || type
}

export function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(amount)
}
